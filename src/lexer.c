/* Generated by re2c 4.3 */
#line 1 "src/lexer.re"
/*
 * re2c-based lexer for a JS subset (LALR 版本，三参 yylex)
 * - Tracks line/col and LineTerminator presence between tokens (for ASI).
 * - Skips whitespace/comments; sets drv->has_line_terminator when a line break is seen before the next token.
 * - Skips UTF-8 BOM (EF BB BF) at file start or between tokens.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "tokens.h"
#include "parser_driver.h"
#include "parser.h"  /* for T_* token macros */

typedef struct {
  const char *cursor;
  const char *limit;
  const char *marker;
  const char *tok_start;
} YYCTX;

static void advance_line(ParserDriver *drv) { drv->line++; drv->col = 1; }
static void advance_cols(ParserDriver *drv, int n) { drv->col += n; }

static int kw(const char *s, int len) {
  #define KW(x, tok) if (len==(int)sizeof(x)-1 && memcmp(s,x,len)==0) return tok
  KW("var", T_K_VAR);
  KW("let", T_K_LET);
  KW("const", T_K_CONST);
  KW("function", T_K_FUNCTION);
  KW("return", T_K_RETURN);
  KW("if", T_K_IF);
  KW("else", T_K_ELSE);
  KW("while", T_K_WHILE);
  KW("do", T_K_DO);
  KW("for", T_K_FOR);
  KW("break", T_K_BREAK);
  KW("continue", T_K_CONTINUE);
  KW("throw", T_K_THROW);
  KW("try", T_K_TRY);
  KW("catch", T_K_CATCH);
  KW("finally", T_K_FINALLY);
  KW("true", T_K_TRUE);
  KW("false", T_K_FALSE);
  KW("null", T_K_NULL);
  KW("new", T_K_NEW);
  KW("this", T_K_THIS);
  KW("typeof", T_K_TYPEOF);
  KW("void", T_K_VOID);
  KW("delete", T_K_DELETE);
  KW("in", T_K_IN);
  KW("instanceof", T_K_INSTANCEOF);
  KW("switch", T_K_SWITCH);
  KW("case", T_K_CASE);
  KW("default", T_K_DEFAULT);
  KW("debugger", T_K_DEBUGGER);
  KW("of", T_K_OF);
  #undef KW
  return 0;
}

/* LALR 下 bison 调 yylex(YYSTYPE*, scanner, drv)：三参版本 */
int yylex(int *yylval, void *scanner, ParserDriver *drv) {
  (void)yylval; (void)scanner;
  YYCTX ctx;
  ctx.cursor = drv->buf + drv->pos;
  ctx.limit  = drv->buf + drv->len;
  ctx.marker = ctx.cursor;

  int saw_line = 0;

  // Skip whitespace and comments; record if any LineTerminator encountered
  for (;;) {
    if (ctx.cursor >= ctx.limit) break;
    unsigned char c = (unsigned char)*ctx.cursor;

    // UTF-8 BOM (EF BB BF) treated as whitespace; keep column unchanged
    if (c==0xEF && (ctx.cursor+2)<ctx.limit &&
        (unsigned char)ctx.cursor[1]==0xBB &&
        (unsigned char)ctx.cursor[2]==0xBF) {
      ctx.cursor += 3;
      drv->pos   += 3;
      continue;
    }

    // spaces and tabs and other non-LT whitespace
    if (c==' ' || c=='\t' || c=='\r' || c=='\f' || c==0x0b) {
      ctx.cursor++; drv->pos++; advance_cols(drv, 1); continue;
    }
    // newline as line terminator
    if (c=='\n') {
      ctx.cursor++; drv->pos++; advance_line(drv); saw_line = 1; continue;
    }
    // single-line comment //
    if (c=='/' && (ctx.cursor+1)<ctx.limit && ctx.cursor[1]=='/') {
      ctx.cursor += 2; drv->pos += 2; advance_cols(drv, 2);
      while (ctx.cursor < ctx.limit && *ctx.cursor != '\n') {
        ctx.cursor++; drv->pos++; advance_cols(drv, 1);
      }
      continue;
    }
    // multi-line comment /* ... */
    if (c=='/' && (ctx.cursor+1)<ctx.limit && ctx.cursor[1]=='*') {
      ctx.cursor += 2; drv->pos += 2; advance_cols(drv, 2);
      while (ctx.cursor < ctx.limit) {
        unsigned char d = (unsigned char)*ctx.cursor;
        if (d == '\n') { ctx.cursor++; drv->pos++; advance_line(drv); saw_line = 1; continue; }
        if (d=='*' && (ctx.cursor+1)<ctx.limit && ctx.cursor[1]=='/') {
          ctx.cursor += 2; drv->pos += 2; advance_cols(drv, 2);
          break;
        }
        ctx.cursor++; drv->pos++; advance_cols(drv, 1);
      }
      continue;
    }
    break;
  }

  drv->has_line_terminator = saw_line ? 1 : 0;

  if (ctx.cursor >= ctx.limit) {
    drv->pos = (size_t)(ctx.cursor - drv->buf);
    return 0; /* EOF */
  }

  drv->pos = (size_t)(ctx.cursor - drv->buf);
  ctx.tok_start = ctx.cursor;

  
#line 134 "src/lexer.c"
{
	unsigned char yych;
	unsigned int yyaccept = 0;
	yych = *ctx.cursor;
	switch (yych) {
		case '!': goto yy3;
		case '"': goto yy5;
		case '$':
		case 'A' ... 'Z':
		case '_':
		case 'a' ... 'z': goto yy6;
		case '%': goto yy8;
		case '&': goto yy10;
		case '\'': goto yy12;
		case '(': goto yy13;
		case ')': goto yy14;
		case '*': goto yy15;
		case '+': goto yy17;
		case ',': goto yy19;
		case '-': goto yy20;
		case '.': goto yy22;
		case '/': goto yy23;
		case '0': goto yy25;
		case '1' ... '9': goto yy27;
		case ':': goto yy29;
		case ';': goto yy30;
		case '<': goto yy31;
		case '=': goto yy33;
		case '>': goto yy35;
		case '?': goto yy37;
		case '[': goto yy38;
		case ']': goto yy39;
		case '^': goto yy40;
		case '{': goto yy42;
		case '|': goto yy43;
		case '}': goto yy45;
		case '~': goto yy46;
		default: goto yy1;
	}
yy1:
	++ctx.cursor;
yy2:
#line 215 "src/lexer.re"
	{
      drv->pos += 1; advance_cols(drv, 1);
      return *(unsigned char*)ctx.tok_start;
    }
#line 182 "src/lexer.c"
yy3:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy47;
		default: goto yy4;
	}
yy4:
#line 174 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_NOT; }
#line 192 "src/lexer.c"
yy5:
	yyaccept = 0;
	yych = *(ctx.marker = ++ctx.cursor);
	switch (yych) {
		case '\n': goto yy2;
		default: goto yy50;
	}
yy6:
	yych = *++ctx.cursor;
	switch (yych) {
		case '$':
		case '0' ... '9':
		case 'A' ... 'Z':
		case '_':
		case 'a' ... 'z': goto yy6;
		default: goto yy7;
	}
yy7:
#line 207 "src/lexer.re"
	{
      int len = (int)(ctx.cursor - ctx.tok_start);
      int tok = kw((const char*)ctx.tok_start, len);
      drv->pos += len; advance_cols(drv, len);
      if (tok) return tok;
      return T_IDENTIFIER;
    }
#line 219 "src/lexer.c"
yy8:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy54;
		default: goto yy9;
	}
yy9:
#line 186 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_MOD; }
#line 229 "src/lexer.c"
yy10:
	yych = *++ctx.cursor;
	switch (yych) {
		case '&': goto yy55;
		case '=': goto yy56;
		default: goto yy11;
	}
yy11:
#line 176 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_BIT_AND; }
#line 240 "src/lexer.c"
yy12:
	yyaccept = 0;
	yych = *(ctx.marker = ++ctx.cursor);
	switch (yych) {
		case '\n': goto yy2;
		default: goto yy58;
	}
yy13:
	++ctx.cursor;
#line 192 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_LPAREN; }
#line 252 "src/lexer.c"
yy14:
	++ctx.cursor;
#line 193 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_RPAREN; }
#line 257 "src/lexer.c"
yy15:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy61;
		default: goto yy16;
	}
yy16:
#line 184 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_MUL; }
#line 267 "src/lexer.c"
yy17:
	yych = *++ctx.cursor;
	switch (yych) {
		case '+': goto yy62;
		case '=': goto yy63;
		default: goto yy18;
	}
yy18:
#line 182 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_PLUS; }
#line 278 "src/lexer.c"
yy19:
	++ctx.cursor;
#line 189 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_COMMA; }
#line 283 "src/lexer.c"
yy20:
	yych = *++ctx.cursor;
	switch (yych) {
		case '-': goto yy64;
		case '=': goto yy65;
		default: goto yy21;
	}
yy21:
#line 183 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_MINUS; }
#line 294 "src/lexer.c"
yy22:
	++ctx.cursor;
#line 187 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_DOT; }
#line 299 "src/lexer.c"
yy23:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy66;
		default: goto yy24;
	}
yy24:
#line 185 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_DIV; }
#line 309 "src/lexer.c"
yy25:
	yyaccept = 1;
	yych = *(ctx.marker = ++ctx.cursor);
	switch (yych) {
		case 'b': goto yy68;
		case 'o': goto yy69;
		case 'x': goto yy70;
		default: goto yy28;
	}
yy26:
#line 205 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv,(int)l); return T_NUMERIC; }
#line 322 "src/lexer.c"
yy27:
	yyaccept = 1;
	yych = *(ctx.marker = ++ctx.cursor);
yy28:
	switch (yych) {
		case '.': goto yy67;
		case '0' ... '9': goto yy27;
		default: goto yy26;
	}
yy29:
	++ctx.cursor;
#line 190 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_COLON; }
#line 336 "src/lexer.c"
yy30:
	++ctx.cursor;
#line 188 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_SEMI; }
#line 341 "src/lexer.c"
yy31:
	yych = *++ctx.cursor;
	switch (yych) {
		case '<': goto yy71;
		case '=': goto yy73;
		default: goto yy32;
	}
yy32:
#line 180 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_LT; }
#line 352 "src/lexer.c"
yy33:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy74;
		default: goto yy34;
	}
yy34:
#line 179 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_ASSIGN; }
#line 362 "src/lexer.c"
yy35:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy76;
		case '>': goto yy77;
		default: goto yy36;
	}
yy36:
#line 181 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_GT; }
#line 373 "src/lexer.c"
yy37:
	++ctx.cursor;
#line 191 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_QMARK; }
#line 378 "src/lexer.c"
yy38:
	++ctx.cursor;
#line 196 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_LBRACK; }
#line 383 "src/lexer.c"
yy39:
	++ctx.cursor;
#line 197 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_RBRACK; }
#line 388 "src/lexer.c"
yy40:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy79;
		default: goto yy41;
	}
yy41:
#line 178 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_BIT_XOR; }
#line 398 "src/lexer.c"
yy42:
	++ctx.cursor;
#line 194 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_LBRACE; }
#line 403 "src/lexer.c"
yy43:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy80;
		case '|': goto yy81;
		default: goto yy44;
	}
yy44:
#line 177 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_BIT_OR; }
#line 414 "src/lexer.c"
yy45:
	++ctx.cursor;
#line 195 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_RBRACE; }
#line 419 "src/lexer.c"
yy46:
	++ctx.cursor;
#line 175 "src/lexer.re"
	{ drv->pos += 1; advance_cols(drv,1); return T_BIT_NOT; }
#line 424 "src/lexer.c"
yy47:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy82;
		default: goto yy48;
	}
yy48:
#line 159 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_NEQ; }
#line 434 "src/lexer.c"
yy49:
	yych = *++ctx.cursor;
yy50:
	switch (yych) {
		case '\n': goto yy51;
		case '"': goto yy52;
		case '\\': goto yy53;
		default: goto yy49;
	}
yy51:
	ctx.cursor = ctx.marker;
	if (yyaccept == 0) goto yy2;
	else goto yy26;
yy52:
	++ctx.cursor;
#line 200 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv, (int)l); return T_STRING; }
#line 452 "src/lexer.c"
yy53:
	yych = *++ctx.cursor;
	switch (yych) {
		case '\n': goto yy51;
		default: goto yy49;
	}
yy54:
	++ctx.cursor;
#line 168 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_MOD_ASSIGN; }
#line 463 "src/lexer.c"
yy55:
	++ctx.cursor;
#line 156 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_AND; }
#line 468 "src/lexer.c"
yy56:
	++ctx.cursor;
#line 169 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_AND_ASSIGN; }
#line 473 "src/lexer.c"
yy57:
	yych = *++ctx.cursor;
yy58:
	switch (yych) {
		case '\n': goto yy51;
		case '\'': goto yy59;
		case '\\': goto yy60;
		default: goto yy57;
	}
yy59:
	++ctx.cursor;
#line 199 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv, (int)l); return T_STRING; }
#line 487 "src/lexer.c"
yy60:
	yych = *++ctx.cursor;
	switch (yych) {
		case '\n': goto yy51;
		default: goto yy57;
	}
yy61:
	++ctx.cursor;
#line 166 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_MUL_ASSIGN; }
#line 498 "src/lexer.c"
yy62:
	++ctx.cursor;
#line 162 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_INC; }
#line 503 "src/lexer.c"
yy63:
	++ctx.cursor;
#line 164 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_ADD_ASSIGN; }
#line 508 "src/lexer.c"
yy64:
	++ctx.cursor;
#line 163 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_DEC; }
#line 513 "src/lexer.c"
yy65:
	++ctx.cursor;
#line 165 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_SUB_ASSIGN; }
#line 518 "src/lexer.c"
yy66:
	++ctx.cursor;
#line 167 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_DIV_ASSIGN; }
#line 523 "src/lexer.c"
yy67:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '9': goto yy83;
		default: goto yy51;
	}
yy68:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '1': goto yy84;
		default: goto yy51;
	}
yy69:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '7': goto yy86;
		default: goto yy51;
	}
yy70:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '9':
		case 'A' ... 'F':
		case 'a' ... 'f': goto yy88;
		default: goto yy51;
	}
yy71:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy90;
		default: goto yy72;
	}
yy72:
#line 172 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_SHL; }
#line 559 "src/lexer.c"
yy73:
	++ctx.cursor;
#line 160 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_LTE; }
#line 564 "src/lexer.c"
yy74:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy91;
		default: goto yy75;
	}
yy75:
#line 158 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_EQ; }
#line 574 "src/lexer.c"
yy76:
	++ctx.cursor;
#line 161 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_GTE; }
#line 579 "src/lexer.c"
yy77:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy92;
		case '>': goto yy93;
		default: goto yy78;
	}
yy78:
#line 173 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_SHR; }
#line 590 "src/lexer.c"
yy79:
	++ctx.cursor;
#line 171 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_XOR_ASSIGN; }
#line 595 "src/lexer.c"
yy80:
	++ctx.cursor;
#line 170 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_OR_ASSIGN; }
#line 600 "src/lexer.c"
yy81:
	++ctx.cursor;
#line 157 "src/lexer.re"
	{ drv->pos += 2; advance_cols(drv,2); return T_OR;  }
#line 605 "src/lexer.c"
yy82:
	++ctx.cursor;
#line 151 "src/lexer.re"
	{ drv->pos += 4; advance_cols(drv,4); return T_STRICT_NEQ; }
#line 610 "src/lexer.c"
yy83:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '9': goto yy83;
		default: goto yy26;
	}
yy84:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '1': goto yy84;
		default: goto yy85;
	}
yy85:
#line 203 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv,(int)l); return T_NUMERIC; }
#line 626 "src/lexer.c"
yy86:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '7': goto yy86;
		default: goto yy87;
	}
yy87:
#line 204 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv,(int)l); return T_NUMERIC; }
#line 636 "src/lexer.c"
yy88:
	yych = *++ctx.cursor;
	switch (yych) {
		case '0' ... '9':
		case 'A' ... 'F':
		case 'a' ... 'f': goto yy88;
		default: goto yy89;
	}
yy89:
#line 202 "src/lexer.re"
	{ size_t l = ctx.cursor - ctx.tok_start; drv->pos += l; advance_cols(drv,(int)l); return T_NUMERIC; }
#line 648 "src/lexer.c"
yy90:
	++ctx.cursor;
#line 154 "src/lexer.re"
	{ drv->pos += 3; advance_cols(drv,3); return T_SHL_ASSIGN; }
#line 653 "src/lexer.c"
yy91:
	++ctx.cursor;
#line 150 "src/lexer.re"
	{ drv->pos += 3; advance_cols(drv,3); return T_STRICT_EQ; }
#line 658 "src/lexer.c"
yy92:
	++ctx.cursor;
#line 153 "src/lexer.re"
	{ drv->pos += 3; advance_cols(drv,3); return T_SHR_ASSIGN; }
#line 663 "src/lexer.c"
yy93:
	yych = *++ctx.cursor;
	switch (yych) {
		case '=': goto yy95;
		default: goto yy94;
	}
yy94:
#line 152 "src/lexer.re"
	{ drv->pos += 3; advance_cols(drv,3); return T_USHR; }
#line 673 "src/lexer.c"
yy95:
	++ctx.cursor;
#line 155 "src/lexer.re"
	{ drv->pos += 4; advance_cols(drv,4); return T_USHR_ASSIGN; }
#line 678 "src/lexer.c"
}
#line 219 "src/lexer.re"

  return 0;
}

/* Peek next token kind and whether a LineTerminator appeared before it. */
int yypeek_token(void *scanner, ParserDriver *drv, int *tok_out, int *lt_out) {
  ParserDriver tmp = *drv; /* copy driver state */
  int dummy = 0;
  int tok = yylex(&dummy, scanner, &tmp);
  *tok_out = tok;
  *lt_out = tmp.has_line_terminator;
  return 0;
}

/* stubs */
int yylex_init_extra(ParserDriver *drv, void **scanner) { (void)drv; *scanner = (void*)0x1; return 0; }
int yylex_destroy(void *scanner) { (void)scanner; return 0; }
int yy_scan_bytes(const char *bytes, size_t len, void *scanner) { (void)bytes; (void)len; (void)scanner; return 0; }
void yyset_in(FILE *in_str, void *scanner) { (void)in_str; (void)scanner; }
